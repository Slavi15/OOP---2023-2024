#  Задача 1

* За задачата можете да използвате класа string реализиран на семинари.

Windows forms е UI framework за лесно създаване на приложения за windows. Той
представя лесен начин за създаване на приложения графично и се поддържа от
езикци като C#. Приложенията представляват множество от форми в които има
контроли.
Да се създаде клас, който представя форма. Формата има размер (широчина и дължина), както и име. Всяка форма поддържа колекция от контроли.
Всеки контрол има размер и локация във формата. Също така, всеки контрол има
функция setDataDialog(); която позволява на потребителя да промени контрола по
подходящ начин. Всеки контрол може да променя размерите си.
Имаме следните контроли:

1. Label - Това е просто етикетче. То има текст в него. setDataDialog() променя
    текста му.
2. CheckBox - Контрол, който има текст и състояние (включен или изключен).
    setDataDialog() променя дали е включен или изключен по подразбиране. За
    промяна на текста може да добавите допълнителна функция.
3. Radio Button - Контрол, който има няколко опции, но само една е избрана.
    setDataDialog() променя избраната опция. Може да добавите допълнителна
    логика за промяната на опциите. Броят им, веднъж зададен, не се променя.

Реализирайте хетерогенен контейнер, който съдържа различните контроли, които
вашата форма притежава. Трябва да имате метод за добавяне на контрола към контейнера. Също така трябва да имате метод за променяне на размера на формата
както и на всеки от контролите (може да достъпвате контролите по индекс). Напи-
шете функция за промяна на локацията на контролите, като те не трябва да излизат
извън формата.
Реализирайте метод change(size_t index); който променя контрола на подадения индекс. Промяната става чрез извикване на setDataDialog функцията на съответния
контрол.

# Задача 2
## Sets - класове

Разглеждаме абстрактен базов клас `Множество`, което е съставено от стрингове. Едно множество задължително трябва да има оператор за индексиране, който връща булев резултат дали подадения като аргумент елемент принадлежи на множеството.

Наследници на това множество са следните конкретни класове:

- `Крайно множество` - елементи се подават като масив в конструктора.

- `Множество-интервал` – в конструктора се подават два елемента – граници на интервала. Всички елементи на множеството трябва да са в интервала **(затворен интервал).**

- `Множество по критерий` – в конструктора се подава **предикат (булева функция)**, който определя дали даден елемент принадлежи на множеството. По-надолу в описанията на множествата има различни видове критерии. Помислете как да направите това множество, така че да не се интересувате какъв е критерият.

- `Сечение на множества` – в конструктора се подават едно или повече множества. Създаденият обект (сечение) съдържа даден елемент, когато този елемент се съдържа във всяко от подадените множества.

- `Обединение на множества` - в конструктора се подават едно или повече множества. Създаденият обект (обединение) съдържа даден елемент, когато този елемент се съдържа в поне едно от подадените множества.

- Добавете метод за добавяне на множество към `Обединение` и `Сечение`

## Sets - файлова система

Реализирайте програма, която прочита от текстов файл множество от символни низове – имена на **двоични** файлове. Всяко име е разположено на **отделен ред** и съдържа валидно име на двоичен файл в съответната файлова система. Съдържание на всеки двоичен файл:

- В началото на всеки файл има едно 32-битово число - **stringsCount**, следвано от едно 8-битово число **addType** 
- След тях има **stringsCount** на брой стринга. Преди всеки стринг има данни за него във вида: </br>
{число(int) **stringLength**}{**stringLength** символа} 

Стойността на **addType** разглеждаме като поредица от битове, която определя какъв тип множество ще определят тези низове и как ще се добави то към резултата. Най-младшите два бита определят начина на добавяне, а най-старшите три бита определят типа на множеството.

За начин на добавяне разглеждаме три стойности:
- `0` – съответното множество замества резултата, без значение на предишни прочетени множества
- `1` – съответното множество се добавя като обединение към получения до момента резултат
- `2` – съответното множество се добавя като сечение към получения до момента резултат

За тип на множествата разглеждаме следните стойности:
- `0` – Файлът описва **крайно** множество. **Елементите са всичките низове от текущия файл**.
- `1` – Файлът описва **множество - интервал**. В този случай **stringsCount задължително трябва да е 2**. Двата последващи низа определят интервала.
- `2` – Файлът описва **множество по критерий**. Негови елементи са **низовете, които съдържат някой от подадените stringsCount низа в себе си**.
- `3` – Файлът описва **множество по критерий**. **Негови елементи са низовете, които са конкатенация на някои два от подадените низове**.
- `4` – Файлът описва **сечение на множество интервали**. **stringsCount задължително трябва да е четно число**. Всеки два последователни низа във файла описват един интервал и **резултатното множество е сечението им**.
- `5` – Файлът описва **обединение на множество интервали**. **stringsCount задължително трябва да е четно число**. Всеки два последователни низа във файла описват един интервал и **резултатното множество е обединението им**.

!!! За множеството от първия файл се игнорира начина му на добавяне. То става начално множество 

От данните във всеки файл създайте съответното множество. Това множество добавете към резултатно множество, съгласно описаното във файла – замяна, обединение и съответно сечение с него. Започвате да прилагате операциите от втория файл към първия, след това от третия към резултата и така нататък.

Накрая въведете от клавиатурата текст до край на файл. За всеки от редовете му проверете дали се съдържа в резултатното множество и изведете броя на тези редове.L